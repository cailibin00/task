# 了解一个c文件到一个可执行文件的全部流程  
## 单文件编译 
 ```mermaid   
 graph LR  
 A[demo.c]-->|预处理|B[demo.i]  
 B-->|编译|C[demo.s]  
 C-->|汇编|D[demo.o]  
 D-->|链接|E[demo.exe]
 ```
### 预处理  
* 替换include  
* 替换宏  
* 条件编译  

我们在写完demo.c的c文件之后，我们启动调试到程序运行，编译器会自动完成几个步骤，使得c文件能够执行，预处理就是第一步**替换include**   
1. 我们知道，我们写C文件第一件事就是#include，头文件中包含了变量声明，函数声明等，编译器首先要将这些东西引入程序之中  
2. 编译器把程序中所用的宏展开成替换文本，只是简单的文本替换，没有计算等功能，叫做**宏替换**  
3. 根据 #if #ifdef 等编译命令以及条件，将源文件的一部分包含进来，也就是**条件编译**   

我们以demo.c为例  
>接下来打开终端，输入命令  
-E是预处理，-o是给生成的文件命名

`gcc -E demo.c -o demo.i `

 ![预处理1](/yuchuli.png)  
 ![demo.i](/demoi.png)  
 我们划到最下面，发现我们的代码原封不动的在这里，说明现在还没开始编译我们的代码
 ![demo.i2](/demoi2.png)  

 ### 编译  
 实际上就是把我们写的C语言转化成为汇编语言  
 同时，他会检查我们的词法和语法，分析语义，还会优化我们的代码，最后再生成汇编代码  
 值得注意的是，不同的编译器编译出的代码不同   
 >输入指令来将demo.i文件编译  
查看文件中的代码  

 ``gcc -S demo.i`` 

 ![demos](/demos.png)  

 ### 汇编  
 将生成的汇编代码生成机器语言，也就是由二进制0和1组成的二进制文件，这个文件也就是目标文件  

 ` gcc -c demo.s -o demo`  

 我们注意到，文件是无法打开的
 ![demoo](/demoo.png)   

 ### 链接  
 汇编之后文件不能直接执行，他要去链接c库,默认的情况下，是一个动态链接  
 ` ./demo.exe  `  

 <img src="/able.png" width="100%">    

 * **静态链接**  静态链接的时候是以目标文件为单位的。比如我们引用了静态库中某个函数，那么链接器把库中包含某个函数的那个目标文件链接进来，这样有了执行程序所需要的所有东西，在执行的时候运行速度快  
 但是，这样很可能很多没用的函数都被一起链接进来。这样会导致空间的浪费，另外，就是更新比较困难，当库函数的代码修改后，就要重新进行链接形成可执行程序  
 * **动态链接**  动态链接的时候，程序按照模块拆分成各个相对独立部分，在运行的时候才链接成一个可执行文件，并且多个程序在执行时共享同一份副本，增加了灵活性  
 但是每次执行程序都需要进行链接，会导致程序运行速度受损


 ## 多文件编写  
  ```mermaid   
 graph LR  
 A[demo1.c]-->|预处理|B[demo1.i]  
 B-->|编译|C[demo1.s]  
 C-->|汇编|D[demo1.o]  
 A1[demo2.c]-->|预处理|B1[demo2.i]  
 B1-->|编译|C1[demo2.s]  
 C1-->|汇编|D1[demo2.o]   
 A3[demo3.c]-->|预处理|B3[demo3.i]  
 B3-->|编译|C3[demo3.s]  
 C3-->|汇编|D3[demo3.o] 
 D-->E{链接}  
 D1-->E{链接}
 D3-->E{链接} 
 E{链接}-->Z[demo.exe]
 ```    
将多个源文件预处理，编译，汇编之后，链接在同一个可执行程序之中
在多文件编译中，若是修改了某个程序，就将修改了的单个源文件进行编译之后链接便可以生成可执行程序


